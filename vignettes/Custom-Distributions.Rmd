---
title: "Custom Distributions"
author: "Dean Markwick"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Custom Distributions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
library(dirichletprocess)
library(ggplot2)
library(tidyr)
library(dplyr)
its = 10
```


This package allows for easy customisation and for you to mix any distribution provided that you can write a likelihood, prior and posterior distribution. 

## Conjugate Example
Lets say we have observations that we believe come from a mixture of Poisson distributions. 

```{r}
y <- c(rpois(150, 3), rpois(150, 10))
```

To model this as a mixture we need to create our own custom mixing distribution. 

```{r}
pois_md <- MixingDistribution("poisson", c(1,1), "conjugate")
```
This creates the appropriate object that we can then write the appropriate functions for. 

For a conjugate mixture, we need a likelihood:
```{r}
Likelihood.poisson <- function(mdobj, x, theta) as.numeric(dpois(x, theta[[1]]))
```

a prior:
```{r}
PriorDraw.poisson <- function(mdobj, n) list(array(rgamma(n, mdobj$priorParameters[1], mdobj$priorParameters[2]), dim=c(1,1,n)))
```

a posterior:

```{r}
PosteriorDraw.poisson <- function(mdobj, x, n=1){
  
  lambda <- list(array(rgamma(n, mdobj$priorParameters[1]+sum(x), mdobj$priorParameters[2] + nrow(x)), dim=c(1,1,n)))
  return(lambda)
}
```

and a predictive:

```{r}
Predictive.poisson <- function(mdobj, x){
  
  pred <- numeric(length(x))
  for(i in seq_along(x)){
  
    alpha_post <- mdobj$priorParameters[1] + (x[i])
    beta_post <- mdobj$priorParameters[2] + 1
    
    pred[i] <- (mdobj$priorParameters[2] ^  mdobj$priorParameters[1])/gamma(mdobj$priorParameters[1])
    pred[i] <- pred[i] * gamma(alpha_post)/(beta_post^alpha_post)
    pred[i] <- pred[i] * (1/prod(factorial(x[i])))
  
  }
  return(pred)
}
```

We can now create our Dirichlet Process Object 

```{r}
burnin <- its/2
dpobj <- DirichletProcessCreate(y, pois_md)
dpobj <- Initialise(dpobj)

dpobj <- Fit(dpobj, its)
```

Unfortunately, because the Poisson distribution only takes in discrete values we can't use the `plot` command. Instead we will have to draw the posterior a number of times and plot manually. 

```{r plot}
draw_inds <- seq(burnin, its, length.out = 50)

post_funcs <- lapply(draw_inds, PosteriorFunction, dpobj=dpobj)

x_grid <- 0:(max(y)+1)
posterior_function_eval <- data.frame(lapply(post_funcs, function(f) f(x_grid)))

posterior_function_mean = rowMeans(posterior_function_eval)
names(posterior_function_eval) = seq_along(draw_inds)
posterior_function_eval$x = x_grid

posterior_function_eval = gather(posterior_function_eval, index, posterior, -x)

ggplot(data.frame(y=y), aes(x=y)) + geom_density(fill="black") + geom_line(data=posterior_function_eval, aes(x=x, y=posterior, group=index), colour="blue", alpha=0.5) + geom_line(data=data.frame(posterior=posterior_function_mean, x=x_grid, index="Mean"), aes(x=x_grid, y=posterior), colour="red")
```

As we can see, the correct shape of the data has been recovered. This shows how easy it is to define your own mixing distributions provided you can write the appropriate functions needed. 

## Non Conjugate Mixtures
It is slightly trickier defining the functions for a non-conjugate distribution as you need a couple of extra functions for the Metropolis Hastings algorithm for posterior sampling of the individual clusters. 

As an example, we will be using a mixture of gamma distributions. 
```{r}
y <- c(rgamma(100, 2, 4), rgamma(100, 6, 3))
```

Again, first we must define the mixing distribution:
```{r}
gamma_md <- MixingDistribution("gamma", priorParameters = c(0.1, 0.1), "nonconjugate", "positive", mhStepSize=c(0.1, 0.1))
```
Write the likelihood
```{r}
Likelihood.gamma <- function(mdobj, x, theta) as.numeric(dgamma(x, theta[[1]], theta[[2]]))
```
Write the random prior draw function 
```{r}
PriorDraw.gamma <- function(mdobj, n=1) list(array(rexp(n, mdobj$priorParameters[1]), dim=c(1,1,n)), array(rexp(n, mdobj$priorParameters[2]), dim=c(1,1,n)))
```
Write the prior density function
```{r}
PriorDensity.gamma <- function(mdobj, theta) as.numeric(dexp(theta[[1]], mdobj$priorParameters[1]) * dexp(theta[[2]], mdobj$priorParameters[2]))
```
Write the Metropolis Hastings Proposal function
```{r}
MhParameterProposal.gamma <- function(mdobj, old_params){
  
  param_sd <- mdobj$mhStepSize
  new_params <- old_params

  new_params[[1]] <- abs(old_params[[1]] + param_sd[1]*rnorm(1))
  new_params[[2]] <- abs(old_params[[2]] + param_sd[2]*rnorm(1))

  return(new_params)
}
```

This is enough for us to now create the `dpobj`
```{r}
burnin = its/2
dpobj <- DirichletProcessCreate(y, gamma_md)
dpobj <- Initialise(dpobj)
dpobj <- Fit(dpobj, its)
plot(dpobj, TRUE)
```

```{r}
draw_inds <- seq(burnin, its, length.out = 5)

post_funcs <- lapply(draw_inds, PosteriorFunction, dpobj=dpobj)

x_grid <- seq(0,(max(y)+1), by=0.01)
posterior_function_eval <- data.frame(lapply(post_funcs, function(f) f(x_grid)))

posterior_function_mean = rowMeans(posterior_function_eval)
names(posterior_function_eval) = seq_along(draw_inds)
posterior_function_eval$x = x_grid

posterior_function_eval = gather(posterior_function_eval, index, posterior, -x)


ggplot(data.frame(y=y), aes(x=y)) + geom_density(fill="black") + geom_line(data=posterior_function_eval, aes(x=x, y=posterior, group=index), colour="blue", alpha=0.5) + geom_line(data=data.frame(posterior=posterior_function_mean, x=x_grid, index="Mean"), aes(x=x_grid, y=posterior), colour="red")
```


### Truncated Normal

```{r}
require(truncnorm)

Likelihood.trunc <- function(mdObj, x, theta){
  x <- as.vector(x, 'numeric')
  y <- dtruncnorm(x, a=0, b=60*60*24, mean=theta[[1]][, , , drop = TRUE], sd=theta[[2]][, , , drop = TRUE])
  return(as.numeric(y))
}

PriorDraw.trunc <- function(mdObj, n=1){
  theta <- vector("list", 2)
  theta[[1]] <- array(runif(n, 0, 60*60*24), dim=c(1,1,n))
  theta[[2]] <- array(1/rgamma(n, mdObj$priorParameters[1], mdObj$priorParameters[2]), dim=c(1,1,n))
  return(theta)
}

PriorDensity.trunc <- function(mdObj, theta){
  thetaDensity <- dunif(theta[[1]], 0, 60*60*24)
  thetaDensity <- thetaDensity * dgamma(1/theta[[2]], mdObj$priorParameters[1], mdObj$priorParameters[2])
  return(as.numeric(thetaDensity))
}

MhParameterProposal.trunc <- function(mdObj, oldParams){
  mhStepSize <- mdObj$mhStepSize
  newParams <- oldParams
  newParams[[1]] <- abs(oldParams[[1]] + mhStepSize[1]*rnorm(1, 0, 1.7)) %% (60*60*24)
  newParams[[2]] <- abs(oldParams[[2]] + mhStepSize[2]*rnorm(1, 0, 1.7))
  return(newParams)
}

PriorParametersUpdate.trunc <- function(mdObj, clusterParameters, n = 1) {

  hyperPriorParameters <- mdObj$hyperPriorParameters
  priorParameters <- mdObj$priorParameters

  numClusters <- dim(clusterParameters[[1]])[3]

  posteriorShape <- hyperPriorParameters[1] + priorParameters[1] * numClusters
  posteriorRate <- hyperPriorParameters[2] + sum(1/clusterParameters[[2]])

  newGamma <- rgamma(n, posteriorShape, posteriorRate)

  newPriorParameters <- matrix(c(priorParameters[1], newGamma), ncol = 2)
  mdObj$priorParameters <- newPriorParameters

  return(mdObj)
}

```


```{r}
pds <- PosteriorDraw(truncMD, yTrunc, 1000)






```




```{r}
yTrunc <- c(rtruncnorm(100, 0, 60*60*24, 60*60*6, 7500), rtruncnorm(100, 0, 60*60*24, 60*60*18, 7500)) 

mleGuess <- optim(c(10000,10000), function(x) -1*sum(log(dtruncnorm(yTrunc, 0, 60*60*24, x[1], x[2]))))$par

truncMD <- MixingDistribution("trunc", priorParameters = c(2, 15000), "nonconjugate", mhStepSize = c(1, 1), hyperPriorParameters = c(1, 1/1000000))
truncDP <- DirichletProcessCreate(yTrunc, truncMD)
truncDP <- Initialise(truncDP, posterior = TRUE)
```

```{r}
truncDP <- Fit(truncDP, 1000, FALSE, TRUE)
plot(truncDP)

plot(c(199*Likelihood(truncDP$mixingDistribution, yTrunc[1200], truncDP$clusterParameters),
0.2*Likelihood(truncDP$mixingDistribution, yTrunc[1200], PriorDraw(truncDP$mixingDistribution,3))))


plot(density(yTrunc, from=0, to=60*60*24))
lines(density(rtruncnorm(10000, a=0, b=60*60*24, PriorDraw(truncDP$mixingDistribution, 1)[[1]], PriorDraw(truncDP$mixingDistribution, 1)[[2]])), col="red")
lines(density(rtruncnorm(10000, a=0, b=60*60*24, mleGuess[1], mleGuess[2])), col='blue')

```






