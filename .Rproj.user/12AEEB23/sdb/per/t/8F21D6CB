{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Dirichlet Process\"\nauthor: \"Dean Markwick\"\ndate: \"`r Sys.Date()`\"\noutput: rmarkdown::html_vignette\nvignette: >\n  %\\VignetteIndexEntry{Dirichlet Process}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\n\n```{r, include=FALSE}\nlibrary(dirichletprocess)\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(mvtnorm)\n\nkottas_weibull <- function(x, theta) {\n  alpha = theta[[1]][,,,drop=TRUE]\n  lambda = theta[[2]][,,,drop=TRUE]\n  \n  y <- lambda^(-1) * alpha * x^(alpha-1) * exp(-lambda^(-1) * x^alpha)\n  return(y)\n}\n\n```\n\n```{r}\nits <- 10\n```\nIn this vignette we will be demonstrating the various uses that the dirichletprocess package provides. For speed purposes the variable `its` is set to a low number. Increase it to 250+ for the full results. \n\n\n```{r, eval=FALSE}\ny <- rt(200, 3) + 2\ndp <- DirichletProcessGaussian(y)\ndp <- Fit(dp, its)\nplot(dp, single=TRUE)\n```\n\n\n\n\n### Old Faithful\n\nThe Dirichlet Process can be used to fit non-parametric distributions to data. In this example we will show how the `oldfaithful` data can be modelled using Dirichlet process. \n\n```{r oldfaithful plot, fig.align='center'}\nggplot(faithful, aes(x=waiting)) + geom_histogram(bins=20)\n```\n\nWe model this data using the default specifications of the Gaussian Dirichlet Process function. This is adequate for our transformed data. \n\n```{r oldfaithful dp, fig.show='hold'}\nfaithfulTransformed = (faithful$waiting - mean(faithful$waiting))/sd(faithful$waiting)\n\ndpobj = DirichletProcessGaussian(faithfulTransformed)\n\ndpobj = Fit(dpobj, its)\n\nold_faithful_plot <- plot(dpobj)\nprint(old_faithful_plot)\nqplot(seq_along(dpobj$alphaChain), dpobj$alphaChain, geom=\"line\")\n```\n\n\n### Density estimation on a bounded interval\nWe also include the ability to estimate densities on a bounded interval using a Beta distribution mixture model. We simulate some test data from a known mixture of Beta distributions and fit our Beta DP to it. \n```{r simulate data}\ny <- c(rbeta(100, 1, 3), rbeta(100, 7, 3))\n\nbeta_dpobj <- DirichletProcessBeta(y, 1, mhStep = c(0.06, 0.06))\nbeta_dpobj <- Fit(beta_dpobj, its, TRUE)\nplot(beta_dpobj)\n```\n\n```{r}\nxGrid <- seq(0, 1, by=0.01)\n\nbetaRes <- data.frame(x=xGrid, Estimate=PosteriorFunction(beta_dpobj)(xGrid), Actual=0.5*dbeta(xGrid, 1, 3)+0.5*dbeta(xGrid, 7,3))\n\nbetaRes %>% gather(Key, Value, -x) %>% ggplot(aes(x=x, y=Value, colour=Key)) + geom_line()\n\n```\n\n\n### Non Conjugate Mixtures\nWeibull Kottas example.\n\n```{r weibull fit}\nburnin = its/2\ny1 <- rlnorm(160, 0, sqrt(0.25))\ny2 <- rlnorm(40, 1.2, sqrt(0.02))\ny <- c(y1, y2)\n\nweib_dpobj <- DirichletProcessWeibull(y/max(y), c(3, 2, 0.01), mhStepSize = 0.06, verbose=TRUE)\nweib_dpobj <- Fit(weib_dpobj, its, TRUE)\n\nplot(weib_dpobj, single = FALSE)\nplot(weib_dpobj, single = TRUE)\n```\n\n\n\n### Poisson Intensity Estimation\n\nDirichlet processes can be used to estimate the interesting function of an inhomogeneous Poisson process. Here we simulate from a periodic intensity function and estimate such function using a Generalised Beta distribution bounded on the maximum time.  \n\n```{r sin mixture sim}\ny <- cumsum(runif(1000))\n\npdf <- function(x) sin(x/50)^2\naccept_prob <- pdf(y)\npts <- sample(y, 500, prob=accept_prob)\n```\n\n```{r sin dp, fig.align='center'}\nbeta_dpobj <- DirichletProcessBeta(pts, max(pts)*1.01)\nbeta_dpobj <- Fit(beta_dpobj, its)\n\nplot(beta_dpobj)  \n```\n\nHere we can see the fitted density aligns with the true density of the points. We then use the estimated density to calculate the estimated intensity function.  \n\n```{r, echo=FALSE, fig.align='center'}\nx_grid <- seq(0, max(pts)*1.01)\npost_func_eval <- LikelihoodFunction(beta_dpobj)(x_grid)\npost_func_eval <- post_func_eval / max(post_func_eval)\n\npoissonFuncDF <- data.frame(x=x_grid, actual=pdf(x_grid), estimate=post_func_eval)\npoissonFuncDF <- gather(poissonFuncDF, Type, Value, -x)\n\nggplot(poissonFuncDF, aes(x=x, y=Value, colour=Type)) + geom_line()\n```\nHere the estimated intensity function is very close to the true generating function. \n\n\n### Censored Weibull Inference\nWe can also adapt our Dirichlet process to analyse censored data. Censor data consists of the observations, with a indicator variable showing whether the value is censored.\n```{r}\ndata_a <- c(1, 3 ,3, 6, 7, 7, 10, 12, 14, 15, 18 ,19, 22 ,26 , 28 , 29 ,34, 40, 48 ,49)\ndata_a <- 1 + (data_a / max(data_a))\ndata_a <- cbind(data_a, c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1))\ndata_b <- c(1, 1, 2, 2,3,4,5,8,8,9,11,12,14,16,18,21,27,31,38, 44)\ndata_b <- 1 + (data_b / max(data_b))\ndata_b <- cbind(data_b, c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0))\n```\nFor this, we write a new likelihood and construct a new Dirichlet Process object. \n```{r}\nLikelihood.weibullcens <- function(mdobj, x, theta){\n  alpha = theta[[1]][,,,drop=TRUE]\n  lambda = theta[[2]][,,,drop=TRUE]\n  \n  y <- as.numeric(lambda^(-1) * alpha * x[,1]^(alpha-1) * exp(-lambda^(-1) * x[, 1]^alpha))\n  y_cens <- as.numeric(1 - exp(-x[,1]^alpha / lambda))\n  \n  if(nrow(x) == 1){\n    if(x[,2] == 0) return(y)\n    if(x[,2] == 1) return(y_cens)\n  }\n  else{\n    y_ret <- y\n    y_ret[x[,2] == 1] <- y_cens[x[,2]==1]\n    return(y_ret)\n  }\n  \n}\n\nmdobj <- MixingDistribution(\"weibullcens\", c(1,2,1), \"nonconjugate\", mhStepSize=c(0.11,0.11), hyperPriorParameters=c(2,2,1,0.1))\n\nclass(mdobj) <- c(\"list\", \"weibullcens\", \"weibull\", \"nonconjugate\")\n\n```\n\n\n\n```{r}\ntreat_a_dpobj <- DirichletProcessCreate(data_a, mdobj, c(2, 0.9))\ntreat_a_dpobj <- Initialise(treat_a_dpobj)\n\ntreat_b_dpobj <- DirichletProcessCreate(data_b, mdobj, c(2, 0.9))\ntreat_b_dpobj <- Initialise(treat_b_dpobj)\n\ntreat_a_dpobj <- Fit(treat_a_dpobj, its, TRUE)\ntreat_b_dpobj <- Fit(treat_b_dpobj, its, TRUE)\n```\n\n```{r, echo=FALSE}\nindex_chain <- seq(round(its/2), its, length.out = 10)\n\nPosteriorFunction_list = lapply(index_chain, function(i) PosteriorClusters(treat_a_dpobj, i))\nPosteriorFunction_list_b = lapply(index_chain, function(i) PosteriorClusters(treat_b_dpobj, i))\n\nx_grid = seq(1, 2.5, by=0.01)\n\nkottas_weibull <- function(x, theta) {\n  alpha = theta[[1]][,,,drop=TRUE]\n  lambda = theta[[2]][,,,drop=TRUE]\n  \n  y <- lambda^(-1) * alpha * x^(alpha-1) * exp(-lambda^(-1) * x^alpha)\n  return(y)\n}\n\nkottas_weibull_survival <- function(x, theta){\n  alpha = theta[[1]][,,,drop=TRUE]\n  lambda = theta[[2]][,,,drop=TRUE]\n  \n  y <-  1-exp(-x^alpha / lambda)\n  return(y)\n}\n\n\nkottas_weibull_hazard <- function(x, theta){\n  \n  y <- kotta_weibull(x, theta)/kottas_weibull_survival(x, theta)\n  return(y)\n}\n\ntreat_a_mean_density <- rowMeans(data.frame(lapply(PosteriorFunction_list, function(x) weighted_function_generator(kottas_weibull, x$weights, x$params)(x_grid))))\ntreat_b_mean_density <- rowMeans(data.frame(lapply(PosteriorFunction_list_b, function(x) weighted_function_generator(kottas_weibull, x$weights, x$params)(x_grid))))\n\ntreat_a_mean_survival <- rowMeans(data.frame(lapply(PosteriorFunction_list, function(x) weighted_function_generator(kottas_weibull_survival, x$weights, x$params)(x_grid))))\ntreat_b_mean_survival <- rowMeans(data.frame(lapply(PosteriorFunction_list_b, function(x) weighted_function_generator(kottas_weibull_survival, x$weights, x$params)(x_grid))))\n\ntreat_a_hazard <- treat_a_mean_density / (1-treat_a_mean_survival)\ntreat_b_hazard <- treat_b_mean_density / (1-treat_b_mean_survival)\n\n```\n\n\n```{r, fig.align='center'}\nx_grid_a <- (x_grid -1)*49\nx_grid_b <- (x_grid -1)*44\n\ntreatmeant_df_a <- data.frame(A_Density=treat_a_mean_density, A_Survival=1-treat_a_mean_survival, A_Hazard=treat_a_hazard, x=x_grid_a)\n\ntreatmeant_df_b <- data.frame(B_Density=treat_b_mean_density, B_Survival=1-treat_b_mean_survival, B_Hazard=treat_b_hazard, x=x_grid_b)\n\ntreatmeant_df <- bind_rows(gather(treatmeant_df_a, label, value, -x), gather(treatmeant_df_b, label, value, -x))\n\ntreatmeant_df$Group = sapply(treatmeant_df$label, function(x) strsplit(x, \"_\")[[1]][1])\ntreatmeant_df$Function = sapply(treatmeant_df$label, function(x) strsplit(x, \"_\")[[1]][2])\n\ntreatmeant_df %>% filter(Function==c(\"Density\", \"Survival\", \"Hazard\")) %>% ggplot(aes(x=x, y=value, colour=Group, group=Group)) + geom_line() + facet_wrap(~Function, scales = \"free\") + theme(legend.position = \"bottom\") -> weibull_censor_graph\n\nprint(weibull_censor_graph)\n```\n\n\n### Clustering with Multivariate Normal\nDirichlet Process also have clustering applications. Here we demonstrate this by simulating from a two dimensional Gaussian distribution and fitting a Dirichlet process. Using the component labels we can assign the data into appropriate clusters. \n\n\n```{r clustering}\ny <- rbind(rmvnorm(30, c(7,10), diag(2)-0.1), rmvnorm(30, c(1,2), diag(2)+0.1)) \n\ndpobj <- DirichletProcessMvnormal(y)\n\ndt <- data.frame(x=y[,1], y=y[,2], label=as.factor(dpobj$clusterLabels), fit=\"N\")\n\ndpobj <- Fit(dpobj, its)\n```\n\n\n```{r, echo=FALSE,  fig.show='hold'}\ndt <- rbind(dt, data.frame(x=y[,1], y=y[,2], label=as.factor(dpobj$clusterLabels), fit=\"Y\"))\n\nclustering_initial_plot <- ggplot(filter(dt, fit==\"N\"), aes(x=x, y=y, colour=label)) + geom_point() + guides(colour=FALSE)\nclustering_fit_plot <- ggplot(filter(dt, fit==\"Y\"), aes(x=x, y=y, colour=label)) + geom_point() + guides(colour=FALSE)\nprint(clustering_initial_plot)\nprint(clustering_fit_plot)\n```\n\nHere we can see that starting initially with random clusters the data separates itself into the correct generating clusters. \n\n\n\n\n\n### Hierarchical Dirichlet Process\n\nLets consider two intensity functions that have a common component. \n\n```{r}\nmu <- c(0.25, 0.75, 0.4)\ntau <- c(5, 6, 10)\n\na <- mu*tau\nb <- (1-mu)*tau\n\ny1 <- c(rbeta(100, a[1], b[1]), rbeta(100, a[2], b[2]))\ny2 <- c(rbeta(100, a[1], b[1]), rbeta(100, a[3], b[3]))\n\n\n```\n\n\n```{r}\ndpobjlist <- DirichletProcessHierarchicalBeta(list(y1,y2), maxY=1, hyperPriorParameters = c(1, 0.01), mhStepSize = c(0.1, 0.1), gammaPriors = c(2, 4), alphaPriors = c(2, 4))\n\ndpobjlist <- Fit(dpobjlist, its, TRUE)\n\n\nplot(dpobjlist$indDP[[1]])\nplot(dpobjlist$indDP[[2]])\n\nxGrid <- seq(0, 1, by=0.01) \n\nplot(xGrid, 0.5*dbeta(xGrid, a[1], b[1]) + 0.5*dbeta(xGrid, a[2], b[2]), type=\"l\")\nlines(xGrid, PosteriorFunction(dpobjlist$indDP[[1]])(xGrid), col=\"red\")\nplot(xGrid, 0.5*dbeta(xGrid, a[1], b[1]) + 0.5*dbeta(xGrid, a[3], b[3]), type=\"l\")\nlines(xGrid, PosteriorFunction(dpobjlist$indDP[[2]])(xGrid), col=\"red\")\n\n\n```\n\n\n### Normal Fixed Effects\n\nFor our model we have $y_i \\sim N(\\mu _i , \\sigma ^2)$ where there is a basic regression structure on $\\mu_i = \\sum _j \\beta _j x_{ji}$. Our prior on $\\beta$ is a DP $\\beta \\sim G, G \\sim \\text{DP} (\\alpha, G_0)$. \n\nLets simulate some data. An intercept and two other components.\n\n```{r}\nnIndvs <- 1000\n\nbeta0 <- rnorm(nIndvs, 3, 0)\nbeta1 <- rnorm(nIndvs, 1, 0)\nbeta2 <- rnorm(nIndvs, -2, 0)\n\nbetaMat <- cbind(beta0[1], beta1[1], beta2[1])\nxMat <- cbind(rep_len(1, nIndvs), rnorm(nIndvs, 5), rnorm(nIndvs, -5))\n\nmu <- xMat %*% t(betaMat)\n\nsigma <- 3\ny <- rnorm(nIndvs, mu, sigma)\n\nplot(density(y))\nplot(density(mu))\n\nmle <- optim(c(0.5, 0.5,0.5), function(x) -sum(dnorm(y, xMat %*% x, sigma)))\n\n```\n\nTo infer what the parameters are in a non-DP case we would do the following with uninformative priors. \n\nIf we pool all the data togehter.\n```{r}\nbeatHat <- solve(t(xMat) %*% xMat)%*%t(xMat)%*%y\nlambda0 <- diag(1, nrow = 3, ncol=3)\nmu0 <- c(0,0,0)\n\nmu_n <- solve(t(xMat) %*% xMat + lambda0) %*% (lambda0 %*% mu0 + t(xMat)%*%y)\nlambda_n <- t(xMat) %*% xMat + lambda0\ncovMat <- solve(lambda_n)\n\nsmps <- replicate(1000, rnorm(3, mu_n, diag(covMat)*3))\nrowMeans(smps)\n```\n\n```{r}\n\n\n\n\n\n```\n\n\n",
    "created" : 1501843601776.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "837543068",
    "id" : "8F21D6CB",
    "lastKnownWriteTime" : 1504865446,
    "last_content_update" : 1504865446152,
    "path" : "~/Documents/PhD/Research/Dirichelet/dirichletprocess/vignettes/Dirichlet_Process_Example.Rmd",
    "project_path" : "vignettes/Dirichlet_Process_Example.Rmd",
    "properties" : {
        "docOutlineVisible" : "0",
        "ignored_words" : "Dirichlet\n",
        "marks" : "<:364,0\n>:364,0"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}