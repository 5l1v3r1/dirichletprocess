{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Custom Distributions\"\nauthor: \"Dean Markwick\"\ndate: \"`r Sys.Date()`\"\noutput: rmarkdown::html_vignette\nvignette: >\n  %\\VignetteIndexEntry{Custom Distributions}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\n```{r}\nlibrary(dirichletprocess)\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(dplyr)\nits = 10\n```\n\n\nThis package allows for easy customisation and for you to mix any distribution provided that you can write a likelihood, prior and posterior distribution. \n\n## Conjugate Example\nLets say we have observations that we believe come from a mixture of Poisson distributions. \n\n```{r}\ny <- c(rpois(150, 3), rpois(150, 10))\n```\n\nTo model this as a mixture we need to create our own custom mixing distribution. \n\n```{r}\npois_md <- MixingDistribution(\"poisson\", c(1,1), \"conjugate\")\n```\nThis creates the appropriate object that we can then write the appropriate functions for. \n\nFor a conjugate mixture, we need a likelihood:\n```{r}\nLikelihood.poisson <- function(mdobj, x, theta) as.numeric(dpois(x, theta[[1]]))\n```\n\na prior:\n```{r}\nPriorDraw.poisson <- function(mdobj, n) list(array(rgamma(n, mdobj$priorParameters[1], mdobj$priorParameters[2]), dim=c(1,1,n)))\n```\n\na posterior:\n\n```{r}\nPosteriorDraw.poisson <- function(mdobj, x, n=1){\n  \n  lambda <- list(array(rgamma(n, mdobj$priorParameters[1]+sum(x), mdobj$priorParameters[2] + nrow(x)), dim=c(1,1,n)))\n  return(lambda)\n}\n```\n\nand a predictive:\n\n```{r}\nPredictive.poisson <- function(mdobj, x){\n  \n  pred <- numeric(length(x))\n  for(i in seq_along(x)){\n  \n    alpha_post <- mdobj$priorParameters[1] + (x[i])\n    beta_post <- mdobj$priorParameters[2] + 1\n    \n    pred[i] <- (mdobj$priorParameters[2] ^  mdobj$priorParameters[1])/gamma(mdobj$priorParameters[1])\n    pred[i] <- pred[i] * gamma(alpha_post)/(beta_post^alpha_post)\n    pred[i] <- pred[i] * (1/prod(factorial(x[i])))\n  \n  }\n  return(pred)\n}\n```\n\nWe can now create our Dirichlet Process Object \n\n```{r}\nburnin <- its/2\ndpobj <- DirichletProcessCreate(y, pois_md)\ndpobj <- Initialise(dpobj)\n\ndpobj <- Fit(dpobj, its)\n```\n\nUnfortunately, because the Poisson distribution only takes in discrete values we can't use the `plot` command. Instead we will have to draw the posterior a number of times and plot manually. \n\n```{r plot}\ndraw_inds <- seq(burnin, its, length.out = 50)\n\npost_funcs <- lapply(draw_inds, PosteriorFunction, dpobj=dpobj)\n\nx_grid <- 0:(max(y)+1)\nposterior_function_eval <- data.frame(lapply(post_funcs, function(f) f(x_grid)))\n\nposterior_function_mean = rowMeans(posterior_function_eval)\nnames(posterior_function_eval) = seq_along(draw_inds)\nposterior_function_eval$x = x_grid\n\nposterior_function_eval = gather(posterior_function_eval, index, posterior, -x)\n\nggplot(data.frame(y=y), aes(x=y)) + geom_density(fill=\"black\") + geom_line(data=posterior_function_eval, aes(x=x, y=posterior, group=index), colour=\"blue\", alpha=0.5) + geom_line(data=data.frame(posterior=posterior_function_mean, x=x_grid, index=\"Mean\"), aes(x=x_grid, y=posterior), colour=\"red\")\n```\n\nAs we can see, the correct shape of the data has been recovered. This shows how easy it is to define your own mixing distributions provided you can write the appropriate functions needed. \n\n## Non Conjugate Mixtures\nIt is slightly trickier defining the functions for a non-conjugate distribution as you need a couple of extra functions for the Metropolis Hastings algorithm for posterior sampling of the individual clusters. \n\nAs an example, we will be using a mixture of gamma distributions. \n```{r}\ny <- c(rgamma(100, 2, 4), rgamma(100, 6, 3))\n```\n\nAgain, first we must define the mixing distribution:\n```{r}\ngamma_md <- MixingDistribution(\"gamma\", priorParameters = c(0.1, 0.1), \"nonconjugate\", \"positive\", mhStepSize=c(0.1, 0.1))\n```\nWrite the likelihood\n```{r}\nLikelihood.gamma <- function(mdobj, x, theta) as.numeric(dgamma(x, theta[[1]], theta[[2]]))\n```\nWrite the random prior draw function \n```{r}\nPriorDraw.gamma <- function(mdobj, n=1) list(array(rexp(n, mdobj$priorParameters[1]), dim=c(1,1,n)), array(rexp(n, mdobj$priorParameters[2]), dim=c(1,1,n)))\n```\nWrite the prior density function\n```{r}\nPriorDensity.gamma <- function(mdobj, theta) as.numeric(dexp(theta[[1]], mdobj$priorParameters[1]) * dexp(theta[[2]], mdobj$priorParameters[2]))\n```\nWrite the Metropolis Hastings Proposal function\n```{r}\nMhParameterProposal.gamma <- function(mdobj, old_params){\n  \n  param_sd <- mdobj$mhStepSize\n  new_params <- old_params\n\n  new_params[[1]] <- abs(old_params[[1]] + param_sd[1]*rnorm(1))\n  new_params[[2]] <- abs(old_params[[2]] + param_sd[2]*rnorm(1))\n\n  return(new_params)\n}\n```\n\nThis is enough for us to now create the `dpobj`\n```{r}\nburnin = its/2\ndpobj <- DirichletProcessCreate(y, gamma_md)\ndpobj <- Initialise(dpobj)\ndpobj <- Fit(dpobj, its)\nplot(dpobj, TRUE)\n```\n\n```{r}\ndraw_inds <- seq(burnin, its, length.out = 5)\n\npost_funcs <- lapply(draw_inds, PosteriorFunction, dpobj=dpobj)\n\nx_grid <- seq(0,(max(y)+1), by=0.01)\nposterior_function_eval <- data.frame(lapply(post_funcs, function(f) f(x_grid)))\n\nposterior_function_mean = rowMeans(posterior_function_eval)\nnames(posterior_function_eval) = seq_along(draw_inds)\nposterior_function_eval$x = x_grid\n\nposterior_function_eval = gather(posterior_function_eval, index, posterior, -x)\n\n\nggplot(data.frame(y=y), aes(x=y)) + geom_density(fill=\"black\") + geom_line(data=posterior_function_eval, aes(x=x, y=posterior, group=index), colour=\"blue\", alpha=0.5) + geom_line(data=data.frame(posterior=posterior_function_mean, x=x_grid, index=\"Mean\"), aes(x=x_grid, y=posterior), colour=\"red\")\n```\n\n\n### Truncated Normal\n\n```{r}\nrequire(truncnorm)\n\nLikelihood.trunc <- function(mdObj, x, theta){\n  x <- as.vector(x, 'numeric')\n  y <- dtruncnorm(x, a=0, b=60*60*24, mean=theta[[1]][, , , drop = TRUE], sd=theta[[2]][, , , drop = TRUE])\n  return(as.numeric(y))\n}\n\nPriorDraw.trunc <- function(mdObj, n=1){\n  theta <- vector(\"list\", 2)\n  theta[[1]] <- array(runif(n, 0, 60*60*24), dim=c(1,1,n))\n  theta[[2]] <- array(1/rgamma(n, mdObj$priorParameters[1], mdObj$priorParameters[2]), dim=c(1,1,n))\n  return(theta)\n}\n\nPriorDensity.trunc <- function(mdObj, theta){\n  thetaDensity <- dunif(theta[[1]], 0, 60*60*24)\n  thetaDensity <- thetaDensity * dgamma(1/theta[[2]], mdObj$priorParameters[1], mdObj$priorParameters[2])\n  return(as.numeric(thetaDensity))\n}\n\nMhParameterProposal.trunc <- function(mdObj, oldParams){\n  mhStepSize <- mdObj$mhStepSize\n  newParams <- oldParams\n  newParams[[1]] <- abs(oldParams[[1]] + mhStepSize[1]*rnorm(1, 0, 1.7)) %% (60*60*24)\n  newParams[[2]] <- abs(oldParams[[2]] + mhStepSize[2]*rnorm(1, 0, 1.7))\n  return(newParams)\n}\n\nPriorParametersUpdate.trunc <- function(mdObj, clusterParameters, n = 1) {\n\n  hyperPriorParameters <- mdObj$hyperPriorParameters\n  priorParameters <- mdObj$priorParameters\n\n  numClusters <- dim(clusterParameters[[1]])[3]\n\n  posteriorShape <- hyperPriorParameters[1] + priorParameters[1] * numClusters\n  posteriorRate <- hyperPriorParameters[2] + sum(1/clusterParameters[[2]])\n\n  newGamma <- rgamma(n, posteriorShape, posteriorRate)\n\n  newPriorParameters <- matrix(c(priorParameters[1], newGamma), ncol = 2)\n  mdObj$priorParameters <- newPriorParameters\n\n  return(mdObj)\n}\n\n```\n\n\n```{r}\npds <- PosteriorDraw(truncMD, yTrunc, 1000)\n\n\n\n\n\n\n```\n\n\n\n\n```{r}\nyTrunc <- c(rtruncnorm(100, 0, 60*60*24, 60*60*6, 7500), rtruncnorm(100, 0, 60*60*24, 60*60*18, 7500)) \n\nmleGuess <- optim(c(10000,10000), function(x) -1*sum(log(dtruncnorm(yTrunc, 0, 60*60*24, x[1], x[2]))))$par\n\ntruncMD <- MixingDistribution(\"trunc\", priorParameters = c(2, 15000), \"nonconjugate\", mhStepSize = c(1, 1), hyperPriorParameters = c(1, 1/1000000))\ntruncDP <- DirichletProcessCreate(yTrunc, truncMD)\ntruncDP <- Initialise(truncDP, posterior = TRUE)\n```\n\n```{r}\ntruncDP <- Fit(truncDP, 1000, FALSE, TRUE)\nplot(truncDP)\n\nplot(c(199*Likelihood(truncDP$mixingDistribution, yTrunc[1200], truncDP$clusterParameters),\n0.2*Likelihood(truncDP$mixingDistribution, yTrunc[1200], PriorDraw(truncDP$mixingDistribution,3))))\n\n\nplot(density(yTrunc, from=0, to=60*60*24))\nlines(density(rtruncnorm(10000, a=0, b=60*60*24, PriorDraw(truncDP$mixingDistribution, 1)[[1]], PriorDraw(truncDP$mixingDistribution, 1)[[2]])), col=\"red\")\nlines(density(rtruncnorm(10000, a=0, b=60*60*24, mleGuess[1], mleGuess[2])), col='blue')\n\n```\n\n\n\n\n\n\n",
    "created" : 1507539860217.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4177666280",
    "id" : "EAA7B522",
    "lastKnownWriteTime" : 1507573286,
    "last_content_update" : 1507573286396,
    "path" : "~/Documents/PhD/Research/Dirichelet/dirichletprocess/vignettes/Custom-Distributions.Rmd",
    "project_path" : "vignettes/Custom-Distributions.Rmd",
    "properties" : {
        "docOutlineVisible" : "0",
        "marks" : "<:206,0\n>:206,0"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}